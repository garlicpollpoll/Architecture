<img src="https://github.com/user-attachments/assets/01556aad-9eeb-48ed-822c-80bba18a9335">

## 설계 및 개발 동기

메세지 브로커인 Kafka를 학습하면서 Kafka는 Offset 전략을 세울 때 두 가지 전략을 세울 수 있는데 자동 커밋과 수동 커밋이 바로 그것이었죠. 디폴트는 자동 커밋이고 그렇기에 메세지가 유실될 가능성이 존재했습니다. 이를 해결하고자 카프카에선 EOS라는 개념을 도입해 유사 트랜잭션처럼 사용할 수 있었지만, 카프카의 메세지는 이후 데이터베이스 연산과 이어져 카프카의 메세지와 데이터베이스의 연산이 원자성을 이루지 못하였습니다. 때문에 Outbox Pattern을 이용해서 카프카의 메세지와 데이터베이스 연산을 하나로 묶는 과정이 필요했고 Outbox Pattern을 구현하는 방법으로 Transaction Tailling Pattern을 선택하게 되었습니다. 

## 구현 방법

기본적으로 스프링 부트를 이용해서 개발하였으며 트랜잭션 로그를 모니터링할 데몬 스레드를 만들고 EventListener를 이용해 데이터베이스와 연결하여 백그라운드에서 트랜잭션 로그의 커밋을 감지하였습니다. 

## 느낀 점

카프카와 같은 메세지 브로커와 애플리케이션이 어우러지기 위해서는 꽤 큰 노력이 들어간다는 점이 인상깊었습니다. 왜 선배 개발자분들이 MSA는 신중하게 선택하라고 말씀하셨는지 간접적으로 느낄 수 있었습니다. 개인적으로 헥사고날 아키텍처를 공부하기 위해 동기 통신은 gRPC, 비동기 통신은 kafka로 개발해봤지만 복잡도가 정말 말도안되게 올라가 혼자서 개발할 수 있는 수준이 아니어서 중간에 포기하게 되었는데 만약 서비스가 정말 커진다면 수십, 수백의 개발자가 붙어도 쉽게 해결하지 못할 문제라는 것을 간접 체험하게 되었습니다. 

## 블로그 포스팅

[MySQL 트랜잭션 로그 추적](https://coding-review.tistory.com/571) <br>
[메세지 브로커의 근심과 걱정](https://coding-review.tistory.com/566)
